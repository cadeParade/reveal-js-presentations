<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

			<section>
				<h1>Sorting Algorithms</h1>
			</section>

			<section>
				<div>
					<img style="height: 650px;" src="images/shocked-dog.jpg">
				</div>
			</section>

			<section>
				<h2>What is about to happen?</h2>
				<ul>
					<li>Introduction</li>
					<li>Three types of sort:</li>
					<ul>
						<li>Bubble Sort</li>
						<li>Merge Sort</li>
						<li>Quick Sort(quickly)</li>
					</ul>
					<li>Other considerations</li>
					<li>Resources and exercises</li>
				</ul>
			</section>

			<section>
				<h2>Why are sorting algorithms a thing?</h2>
				<p>"Uhh, well, just take the big numbers and put them at the end until they're in order?</p>
				<p class="fragment">No.</p>
				<p class="fragment">Ok, actually that's kind of insertion sort</p>
				<p class="fragment">In any case, computers need incredibly specific instructions.</p>
			</section>

			<section>
				<h2>Any ideas for a sort strategy?</h2>
			</section>

			<section>
				<h2>A simple sort</h2>
				<h3>For a random list</h3>
				<pre><code>[6, 5, 3, 1, 8, 7, 2, 4]</code></pre>
				<p>How might we go about sorting this programmatically?</p>
			</section>

			<section>
				<h2>A simple sort</h2>
				<pre><code style="font-size: 1.5em; line-height: 1.5em">[6, 5, 3, 1, 8, 7, 2, 4]</code></pre>
				<p>Okay, start at the beginning....that's a 6</p>
				<p class="fragment">Look at the next number... that's a 5</p>
				<p class="fragment">Oh! 5 is less than 6, so switch them!</p>
				<pre class="fragment"><code style="font-size: 1.5em; line-height: 1.5em">[5, 6, 3, 1, 8, 7, 2, 4]</code></pre>
				<p class="fragment">Now compare the next two, 6 to three, switch them!</p>
				<p class="fragment">etc...</p>
			</section>

			<section>
				<h2>A simple sort</h2>
					<p><img src="images/bubble-sort.gif"></p>
					<p><a href="http://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Source</a></p>
			</section>

			<section>
				<h2>A Simple Sort</h2>
				<p>Let's code it!</p>
				<pre><code style="font-size: 1.2em; line-height:1.1em">
def bubble_sort(l):

    for i in range(len(l) - 1):
      num1, num2 = l[i], l[i+1]

      if num1 > num2:
        l[i], l[i+1] = num2, num1

    return l
 </code></pre>
 			<p class="fragment">What's wrong with this?</p>
			</section>

		<section>
				<h2>A Simple Sort</h2>
				<p>Let's code it better!</p>
				<pre><code style="font-size: 1.2em; line-height:1.1em">
def bubble_sort(l):
  is_sorted = False

  while is_sorted == False:
    is_sorted=True

    for i in range(len(l) - 1):    # go through each except last
      num1, num2 = l[i], l[i+1]

      if num1 > num2:              # if you have to switch,
        is_sorted = False          # it's not sorted
        l[i], l[i+1] = num2, num1  # switch the numbers
        </code></pre>
        <pre class="fragment"><code style="font-size: 1.2em;">l = bubble_sort([6, 5, 3, 1, 8, 7, 2, 4]) # => 42 steps!</code></pre>
			</section>

			<section>
				<h2>A Simple Sort</h2>
				<p>Runtime?</p>
				<p>Two nested loops, so ....</p>
				<p class="fragment">O(n<sup>2</sup>)</p>
				<p class="fragment">Bonus: Can you make it run in 21 steps (Twice as fast!)?
				<br>Runtime will be O(n<sup>2</sup>/2), so unfortunately still O(n<sup>2</sup>)</p>
			</section>


			<section>
				<h2>Bubble Sort</h2>
				<p>We have just implemented bubble sort!</p>
				<img height="500" src="images/applause.gif">
			</section>

			<section>
				<h2>Others?</h2>
				<ul>
					<li><a href="http://en.wikipedia.org/wiki/Insertion_sort">Insertion Sort</a></li>
					<li><a href="http://en.wikipedia.org/wiki/Selection_sort">Select Sort</a></li>
				</ul>
				<p class="fragment">Worst case: O(n<sup>2</sup>)</p>
				<p class="fragment">Average case: O(n<sup>2</sup>)</p>
				<div><img class="fragment" src="images/quadratic_time.png" height="300"></div>
				<p class="fragment roll-in">: (</p>
			</section>

			<section>
				<h2>We can do better!</h2>
				<img src="images/big-guns.jpg">
				<p class="fragment">ENTER MERGE SORT</p>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<p>Merge sort is awesome because it runs in O(n log(n)) time</p>

				<div>
					<!-- <table>
						<tr>
							<td><img src="images/quadratic_time.png"></td>
							<td><img src="images/logarithmic_time.png"></td>
						</tr>
					</table> -->
						<img src="images/sort/all_big_o.png" alt="">
				</div>


			</section>

<!-- 			<section>
				<h2>Merge Sort</h2>
				<h3>Strategy: Divide and Conquer</h3>
				<p>This can run in O(n log(n)) time because <strong>each time we go through an iteration, the workload is cut in half.</strong></p>
			</section> -->

			<section>
				<h2>Merge Sort</h2>
				<h3>BUT FIRST: MERGE</h3>
				<p>Let's say we have <strong>two already sorted arrays</strong> and we want to <strong>make one sorted array</strong>.</p>
				<pre><code style="font-size:1.5em; line-height: 1.5em">lst1 = [1, 2, 4, 7]
lst2 = [3, 5, 6, 8]
</code></pre>
				<p>How can we merge them?</p>
				<pre><code style="font-size:1.5em; line-height: 1.5em">#output => [1, 2, 3, 4, 5, 6, 7, 8]</code></pre>
			</section>


			<section>
				<h2>Merge Sort</h2>
				<h3>Merge: Strategy</h3>
				<ol>
					<li>Start with two sorted lists</li>
					<li>Initialize new, empty list for results</li>
					<li>Compare first element of each sorted list</li>
					<li>Remove whichever element is lower and add it to the results list.</li>
					<li>Continue comparing the first elements of each list until one of them has no more items.</li>
					<li>Append the remaining items from the other list to results list</li>
				</ol>
				<p class="fragment">Any volunteers? :)</p>
			</section>


			<section>
				<h2>Merge Sort</h2>
				<h3>MERGE</h3>
				<pre><code>def make_one_sorted_list(lst1, lst2):
    result_list = []
    while len(lst1) > 0 and len(lst2) > 0:  #if items left in both lists
        #compare first items of each list
        if lst1[0] < lst2[0]:
            result_list.append(lst1.pop(0))  #append and rm first item of lst1
        else:
            result_list.append(lst2.pop(0))  #append and rm first item of lst2

    result_list.extend(lst1)
    result_list.extend(lst2)

    return result_list

#input lists must be already sorted themselves
print make_one_sorted_list([1, 2, 4, 7], [3, 5, 6, 8])
#output => [1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<h3>BUT FIRST: MERGE</h3>
				<p>This merge solution is generalizeable for any two pre-sorted lists!</p>
				<p class="fragment" data-fragment-index='1'>AWESOME!!</p>
				<p class="fragment" data-fragment-index='2' >But how can we guarantee a pre-sorted list??</p>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<h3>Base Case</h3>
				<p>What kind of list can we KNOW is already pre-sorted?</p>
				<p class="fragment"><strong>A list with one item is always sorted.</strong></p>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<p>How to get down to where every list is one item long?</p>
			</section>

			<section>
				<h2>RECURSION</h2>
<!-- 				<div>
					<div style="display:inline-block;"><h3>Recursion</h3></div>
					<div style="display:inline-block;"><h3>Recursion</h3></div>
				</div> -->
				<h3>RECURSION</h3>
				<h4 style="font-size: 0.8em">recursion</h4>
				<h5 style="font-size: 0.6em">recursion</h5>
				<h6 style="font-size: 0.4em">recursion</h6>
				<h6 style="font-size: 0.2em">recursion</h6>
				<p class="fragment">Any volunteers?</p>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<h3>Make everything a list of one</h3>
				<pre><code>def make_everything_a_list_of_one(lst):
    if len(lst) < 2:      #if length of lst is 1, return lst
        print lst,
        return lst
    mid = int(len(lst)/2)     #index at half the list
    make_everything_a_list_of_one(lst[:mid])      #divide list in half
    make_everything_a_list_of_one(lst[mid:])      #assign other half


lst2 = [3, 5, 6, 8]
make_everything_a_list_of_one(lst2)      #outputs => [3] [5] [6] [8]
</code></pre>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<div><img src="images/sort/merge_sort.png" alt=""></div>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<h3>Your Mission:</h3>
				<p>Combine these to make merge sort</p>
				<p class="fragment">Bonus: Don't decrease length of merging lists (don't use pop)</p>
			</section>

			<section>
				<h2>Merge Sort</h2>
				<h3>Stats</h3>
				<p>Runtime?</p>
				<p class="fragment">O(n log(n))</p>
				<p class="fragment">Runspace?</p>
				<p class="fragment">O(n)</p>
				<p class="fragment">This means that there's n (the length of the list) extra space needed to complete the algorithm. This takes the form of the results list.</p>
			</section>

			<section>
				<h2>Others with O(n log(n))?</h2>
				<ul>
					<li>Quick Sort</li>
				</ul>
				<p>PLUS, operates in place</p>
			</section>

			<section>
				<h2>Quick Sort (quickly)</h2>
				<p>Operates on the idea of a partition</p>
				<p>That is, there is a 'pivot' and we can move all the numbers lower than the pivot number to the beginning of the list and move all the numbers bigger than the pivot to the right of the pivot number.</p>
			</section>

			<section>
				<h2>Pivot</h2>
				<img src="images/sort/quick_sort_flattened.png" alt="">
			</section>

			<section>
				<h2>Further resources:</h2>
				<ul>
					<li>Quicksort intro: https://www.youtube.com/watch?v=aQiWF4E8flQ (6 min) </li>
					<li>Tim Roughgarden Quicksort: https://class.coursera.org/algo-006/lecture (Quicksort-Algorithm, first two lectures)</li>
					<li>"An Intuitive Explanation of Quicksort" http://www.quora.com/What-is-an-intuitive-explanation-of-QuickSort</li>
				</ul>
			</section>

			<section>
				<h2>Why would you choose one over the other?</h2>
				<ul>
					<li>Runtime</li>
					<li>Space requirements (how much more space does it need)</li>
					<li><a href="http://www.sorting-algorithms.com/">Likely structure of your data:</a>
						<ul>
							<li>Random?</li>
							<li>Almost reversed?</li>
							<li>Almost sorted?</li>
							<li>Likely Duplicates?</li>
						</ul>
					</li>
				</ul>
			</section>


			<section>
				<img src="images/wolf-applause.gif" height="500">
			</section>

			<section>
				<h2>Exercises</h2>
				<ul>
					<li>Write bubble sort</li>
					<ul>
						<li>BONUS: Write bubble sort in O(n<sup>2</sup>/2) time</li>
					</ul>
					<li>Write merge sort</li>
					<ul>
						<li>BONUS: Don't change length of sublists (don't use pop)</li>
					</ul>
					<li>Write quick sort</li>
				</ul>
				:)
			</section>

			<section>
				<h2>Resources</h2>
				<ul>
					<li><a href="http://www.sorting-algorithms.com/">Animated Sort Algorithms (compare with gifs!)</a></li>
					<li>Hungarian Dance sorting:
						<ul>
							<li><a href="https://www.youtube.com/watch?v=lyZQPjUT5B4">Bubble Sort</a></li>
							<li><a href="https://www.youtube.com/watch?v=ywWBy6J5gz8">Quick Sort</a></li>
						</ul>
					</li>
				</ul>
			</section>





			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
